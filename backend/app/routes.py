import re
from flask import Blueprint, jsonify, request
from .tools import recon_tools, vuln_assessment_tools, network_scan_tools
from .database import save_models
import json
import concurrent.futures

api = Blueprint('api', __name__)

# Regular expression pattern for validating domain names
domain_pattern = r'^[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'

def is_valid_domain(domain):
    if re.match(domain_pattern, domain):
        return True
    else:
        return False

@api.route('/', methods=['GET'])
def home():
    return "Welcome to Vulnerabillity Assessment Framework Project!"

@api.route('/api/v1/scan-domain', methods=['POST'])
def scan_domain_v1():
    try:
        data = request.json
        domain = data.get('domain')

        if not domain:
            return jsonify({"error": "Domain is required."}), 400

        if not is_valid_domain(domain):
            return jsonify({"error": "Invalid domain format."}), 400

        results = {}
        
        with concurrent.futures.ThreadPoolExecutor() as executor:
            # Part 1: Independent tasks
            futures = {
                executor.submit(recon_tools.get_subdomains, domain): "subdomains",
                executor.submit(recon_tools.get_domain_ip_addresses, domain): "domain_ip_addresses",
                executor.submit(recon_tools.find_virtual_hosts, domain): "virtual_hosts",
                executor.submit(recon_tools.get_leaked_api_tokens, domain): "api_tokens",
                # executor.submit(recon_tools.whois_lookup, domain): "whois_lookup",
                # executor.submit(recon_tools.reverse_dns_lookup, domain): "reverse_dns_lookup",
                # executor.submit(recon_tools.ssl_tls_scan, domain): "ssl_tls_scan",
                # executor.submit(recon_tools.dns_records_enumeration, domain): "dns_records_enumeration",
                # executor.submit(network_scan_tools.analyze_http_headers, domain): "http_headers",
                executor.submit(vuln_assessment_tools.scan_vulnerabilities_with_nikto, domain): "vulnerabilities_with_nikto",
                executor.submit(vuln_assessment_tools.scan_vulnerabilities_with_nessus, domain): "vulnerabilities_with_nessus",
                executor.submit(vuln_assessment_tools.scan_vulnerabilities_with_zap, domain): "vulnerabilities_with_zap",
            }

            for future in concurrent.futures.as_completed(futures):
                task_name = futures[future]
                try:
                    result = future.result()
                    results[task_name] = json.loads(result)
                except Exception as e:
                    results[task_name] = {"error": str(e)}

            # Part 2: Dependent tasks
            domain_ip_addresses_data = results.get("domain_ip_addresses", {})
            subdomains = results.get("subdomains", {})

            if "result" in domain_ip_addresses_data:
                ip_address = domain_ip_addresses_data["result"][0]
                futures = {
                    executor.submit(recon_tools.get_domain_subdomains_ip_addresses, domain, subdomains.get("result", [None])): "domain_subdomains_ip_addresses",
                    executor.submit(network_scan_tools.port_scan, ip_address): "port_scan",
                    # executor.submit(network_scan_tools.service_version_scan, ip_address): "service_version"
                }

                for future in concurrent.futures.as_completed(futures):
                    task_name = futures[future]
                    try:
                        result = future.result()
                        results[task_name] = json.loads(result)
                    except Exception as e:
                        results[task_name] = {"error": str(e)}

        success, message = save_models.save_scan_result(results)

        return jsonify(results)

    except Exception as e:
        code = 500  # Internal Server Error
        response = {
            "error": str(e)
        }
        return jsonify(response), code


@api.route('/api/v2/scan-domain', methods=['POST'])
def scan_domain_v2():
    try:
        data = request.json
        domain = data.get('domain')

        if not domain:
            return jsonify({"error": "Domain is required."}), 400

        if not is_valid_domain(domain):
            return jsonify({"error": "Invalid domain format."}), 400

        results = {}
        
        with concurrent.futures.ThreadPoolExecutor() as executor:
            # Part 1: Independent tasks
            futures = {
                executor.submit(recon_tools.get_subdomains, domain): "subdomains",
                executor.submit(recon_tools.get_domain_ip_addresses, domain): "domain_ip_addresses",
                executor.submit(recon_tools.find_virtual_hosts, domain): "virtual_hosts",
                executor.submit(recon_tools.get_leaked_api_tokens, domain): "api_tokens",
                executor.submit(recon_tools.whois_lookup, domain): "whois_lookup",
                executor.submit(recon_tools.reverse_dns_lookup, domain): "reverse_dns_lookup",
                executor.submit(recon_tools.ssl_tls_scan, domain): "ssl_tls_scan",
                executor.submit(recon_tools.dns_records_enumeration, domain): "dns_records_enumeration",
                executor.submit(network_scan_tools.analyze_http_headers, domain): "http_headers",
                executor.submit(vuln_assessment_tools.scan_vulnerabilities_with_nikto, domain): "vulnerabilities_with_nikto",
                executor.submit(vuln_assessment_tools.scan_vulnerabilities_with_nessus, domain): "vulnerabilities_with_nessus",
                executor.submit(vuln_assessment_tools.scan_vulnerabilities_with_zap, domain): "vulnerabilities_with_zap",
            }

            for future in concurrent.futures.as_completed(futures):
                task_name = futures[future]
                try:
                    result = future.result()
                    results[task_name] = json.loads(result)
                except Exception as e:
                    results[task_name] = {"error": str(e)}

            # Part 2: Dependent tasks
            domain_ip_addresses_data = results.get("domain_ip_addresses", {})
            subdomains = results.get("subdomains", {})

            if "result" in domain_ip_addresses_data:
                ip_address = domain_ip_addresses_data["result"][0]
                futures = {
                    executor.submit(recon_tools.get_domain_subdomains_ip_addresses, domain, subdomains.get("result", [None])): "domain_subdomains_ip_addresses",
                    executor.submit(network_scan_tools.port_scan, ip_address): "port_scan",
                    executor.submit(network_scan_tools.service_version_scan, ip_address): "service_version"
                }

                for future in concurrent.futures.as_completed(futures):
                    task_name = futures[future]
                    try:
                        result = future.result()
                        results[task_name] = json.loads(result)
                    except Exception as e:
                        results[task_name] = {"error": str(e)}

        success, message = save_models.save_scan_result(results)

        return jsonify(results)

    except Exception as e:
        code = 500  # Internal Server Error
        response = {
            "error": str(e)
        }
        return jsonify(response), code
