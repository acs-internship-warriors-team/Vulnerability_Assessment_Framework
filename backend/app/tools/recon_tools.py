import dns.resolver # type: ignore
import requests
from bs4 import BeautifulSoup # type: ignore
import re
import subprocess
import whois
import socket
import json
import ssl

def get_subdomains(domain):
    try:
        result = subprocess.run(['sublist3r', '-d', domain, '-o', 'subdomains.txt'], capture_output=True, text=True)
        with open('subdomains.txt', 'r') as file:
            subdomains = file.readlines()
        return json.dumps({"success": True, "result": [sub.strip() for sub in subdomains]}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def get_domain_ip_addresses(domain):
    try:
        result = dns.resolver.resolve(domain, 'A')
        ips = [ip.address for ip in result]
        return json.dumps({"success": True, "result": ips}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)
    
# def get_domain_subdomains_ip_addresses(domain, subdomains):
#     try:
#         # Get IP addresses for the main domain
#         main_domain_ips = dns.resolver.resolve(domain, 'A')
#         ips = {domain: [ip.address for ip in main_domain_ips]}


#         # Check if subdomains is None or contains None values
#         if subdomains is None or any(subdomain is None for subdomain in subdomains):
#             return json.dumps({"error": "Invalid subdomains list provided."}, indent=4)

#         # Get IP addresses for each valid subdomain
#         for subdomain in subdomains:
#             try:
#                 subdomain_ips = dns.resolver.resolve(subdomain, 'A')
#                 ips[subdomain] = [ip.address for ip in subdomain_ips]
#             except Exception as sub_e:
#                 ips[subdomain] = {"error": str(sub_e)}

#         return json.dumps({"success": True, "result": ips}, indent=4)

#     except Exception as e:
#         return json.dumps({"success": False, "error": str(e)}, indent=4)

def get_domain_subdomains_ip_addresses(domain, subdomains):
    try:
        ips = {}

        # Resolve A records for the main domain
        main_domain_ips = dns.resolver.resolve(domain, 'A')
        ips[domain] = [ip.address for ip in main_domain_ips]

        # Check if subdomains is None or contains None values
        if subdomains is None or any(subdomain is None for subdomain in subdomains):
            return json.dumps({"error": "Invalid subdomains list provided."}, indent=4)

        # Function to resolve IP addresses for a domain or CNAME
        def resolve_ips(target):
            try:
                target_ips = dns.resolver.resolve(target, 'A')
                return [ip.address for ip in target_ips]
            except dns.resolver.NoAnswer:
                return {"error": "No DNS record found for {}".format(target)}
            except dns.resolver.NXDOMAIN:
                return {"error": "The domain {} does not exist.".format(target)}
            except Exception as e:
                return {"error": str(e)}

        # Get IP addresses for each subdomain
        for subdomain in subdomains:
            if subdomain.endswith(domain):
                # Handle direct subdomains with A records
                ips[subdomain] = resolve_ips(subdomain)
            else:
                # Resolve CNAME first and then A records
                try:
                    cname_answer = dns.resolver.resolve(subdomain, 'CNAME')
                    cname_target = str(cname_answer[0].target)
                    ips[subdomain] = {
                        "cname": cname_target,
                        "ip_addresses": resolve_ips(cname_target)
                    }
                except dns.resolver.NoAnswer:
                    ips[subdomain] = {"error": "No DNS record found for {}".format(subdomain)}
                except dns.resolver.NXDOMAIN:
                    ips[subdomain] = {"error": "The domain {} does not exist.".format(subdomain)}
                except Exception as e:
                    ips[subdomain] = {"error": str(e)}

        return json.dumps({"success": True, "result": ips}, indent=4)

    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def find_virtual_hosts(domain):
    try:
        # Perform DNS resolution for common virtual hosts
        virtual_hosts = []
        common_virtual_hosts = ['www', 'ftp', 'mail', 'webmail', 'smtp', 'pop', 'imap']

        for host in common_virtual_hosts:
            subdomain = f"{host}.{domain}"
            try:
                ip_addresses = socket.gethostbyname_ex(subdomain)[2]
                virtual_hosts.append({
                    "subdomain": subdomain,
                    "ip_addresses": ip_addresses
                })
            except socket.gaierror:
                pass  # Ignore DNS resolution errors for non-existing subdomains

        return json.dumps({"success": True, "result": virtual_hosts}, indent=4)
    
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def get_leaked_api_tokens(domain):
    try:
        url = f'http://{domain}'
        response = requests.get(url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Simple regex to find potential API tokens
        api_token_pattern = re.compile(r'(?i)[\'"]?([a-z0-9]{40})[\'"]?')
        api_tokens = api_token_pattern.findall(soup.get_text())
        
        return json.dumps({"success": True, "result": api_tokens}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def find_leaked_tokens(domain):
    try:
        response = requests.get(f"http://{domain}")
        tokens = re.findall(r'([a-zA-Z0-9]{40,})', response.text)
        return json.dumps({"success": True, "result": tokens}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def whois_lookup(domain):
    try:
        w = whois.whois(domain)
        data = {
            "domain_name": w.domain_name,
            "registrar": w.registrar,
            "whois_server": w.whois_server,
            "referral_url": w.referral_url,
            "updated_date": w.updated_date,
            "creation_date": w.creation_date,
            "expiration_date": w.expiration_date,
            "name_servers": w.name_servers,
            "status": w.status,
            "emails": w.emails,
            "dnssec": w.dnssec,
            "name": w.name,
            "org": w.org,
            "address": w.address,
            "city": w.city,
            "state": w.state,
            "zipcode": w.zipcode,
            "country": w.country
        }
        return json.dumps({"success": True, "result": data}, indent=4, default=str)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)
    
def reverse_dns_lookup(domain):
    try:
        ip_address = socket.gethostbyname(domain)
        reverse_dns = socket.gethostbyaddr(ip_address)
        data = {
            "ip_address": ip_address,
            "reverse_dns": reverse_dns[0],
            "aliases": reverse_dns[1],
            "ip_addresses": reverse_dns[2]
        }
        return json.dumps({"success": True, "result": data}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def ssl_tls_scan(domain):
    try:
        context = ssl.create_default_context()
        conn = context.wrap_socket(socket.socket(socket.AF_INET), server_hostname=domain)
        conn.settimeout(3.0)
        conn.connect((domain, 443))
        cert = conn.getpeercert()
        data = {
            "issuer": dict(x[0] for x in cert['issuer']),
            "subject": dict(x[0] for x in cert['subject']),
            "version": cert['version'],
            "serialNumber": cert['serialNumber'],
            "notBefore": cert['notBefore'],
            "notAfter": cert['notAfter'],
        }
        conn.close()
        return json.dumps({"success": True, "result": data}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)

def dns_records_enumeration(domain):
    try:
        records = {}
        for record_type in ['A', 'AAAA', 'MX', 'NS', 'SOA', 'TXT', 'CNAME']:
            try:
                answers = dns.resolver.resolve(domain, record_type)
                records[record_type] = [str(rdata) for rdata in answers]
            except dns.resolver.NoAnswer:
                records[record_type] = []
        return json.dumps({"success": True, "result": records}, indent=4)
    except Exception as e:
        return json.dumps({"success": False, "error": str(e)}, indent=4)
